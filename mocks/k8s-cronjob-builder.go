// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"context"
	"sync"

	"github.com/bborbe/k8s"
	v1a "k8s.io/api/batch/v1"
	v1 "k8s.io/api/core/v1"
	v1b "k8s.io/apimachinery/pkg/apis/meta/v1"
)

type K8sCronJobBuilder struct {
	AddVolumeMountsStub        func(...v1.VolumeMount) k8s.CronJobBuilder
	addVolumeMountsMutex       sync.RWMutex
	addVolumeMountsArgsForCall []struct {
		arg1 []v1.VolumeMount
	}
	addVolumeMountsReturns struct {
		result1 k8s.CronJobBuilder
	}
	addVolumeMountsReturnsOnCall map[int]struct {
		result1 k8s.CronJobBuilder
	}
	AddVolumesStub        func(...v1.Volume) k8s.CronJobBuilder
	addVolumesMutex       sync.RWMutex
	addVolumesArgsForCall []struct {
		arg1 []v1.Volume
	}
	addVolumesReturns struct {
		result1 k8s.CronJobBuilder
	}
	addVolumesReturnsOnCall map[int]struct {
		result1 k8s.CronJobBuilder
	}
	BuildStub        func(context.Context) (*v1a.CronJob, error)
	buildMutex       sync.RWMutex
	buildArgsForCall []struct {
		arg1 context.Context
	}
	buildReturns struct {
		result1 *v1a.CronJob
		result2 error
	}
	buildReturnsOnCall map[int]struct {
		result1 *v1a.CronJob
		result2 error
	}
	SetBackoffLimitStub        func(int) k8s.CronJobBuilder
	setBackoffLimitMutex       sync.RWMutex
	setBackoffLimitArgsForCall []struct {
		arg1 int
	}
	setBackoffLimitReturns struct {
		result1 k8s.CronJobBuilder
	}
	setBackoffLimitReturnsOnCall map[int]struct {
		result1 k8s.CronJobBuilder
	}
	SetCompletionsStub        func(int) k8s.CronJobBuilder
	setCompletionsMutex       sync.RWMutex
	setCompletionsArgsForCall []struct {
		arg1 int
	}
	setCompletionsReturns struct {
		result1 k8s.CronJobBuilder
	}
	setCompletionsReturnsOnCall map[int]struct {
		result1 k8s.CronJobBuilder
	}
	SetCronExpressionStub        func(k8s.CronScheduleExpression) k8s.CronJobBuilder
	setCronExpressionMutex       sync.RWMutex
	setCronExpressionArgsForCall []struct {
		arg1 k8s.CronScheduleExpression
	}
	setCronExpressionReturns struct {
		result1 k8s.CronJobBuilder
	}
	setCronExpressionReturnsOnCall map[int]struct {
		result1 k8s.CronJobBuilder
	}
	SetEnvStub        func([]v1.EnvVar) k8s.CronJobBuilder
	setEnvMutex       sync.RWMutex
	setEnvArgsForCall []struct {
		arg1 []v1.EnvVar
	}
	setEnvReturns struct {
		result1 k8s.CronJobBuilder
	}
	setEnvReturnsOnCall map[int]struct {
		result1 k8s.CronJobBuilder
	}
	SetImageStub        func(string) k8s.CronJobBuilder
	setImageMutex       sync.RWMutex
	setImageArgsForCall []struct {
		arg1 string
	}
	setImageReturns struct {
		result1 k8s.CronJobBuilder
	}
	setImageReturnsOnCall map[int]struct {
		result1 k8s.CronJobBuilder
	}
	SetLoglevelStub        func(int) k8s.CronJobBuilder
	setLoglevelMutex       sync.RWMutex
	setLoglevelArgsForCall []struct {
		arg1 int
	}
	setLoglevelReturns struct {
		result1 k8s.CronJobBuilder
	}
	setLoglevelReturnsOnCall map[int]struct {
		result1 k8s.CronJobBuilder
	}
	SetObjectMetaStub        func(v1b.ObjectMeta) k8s.CronJobBuilder
	setObjectMetaMutex       sync.RWMutex
	setObjectMetaArgsForCall []struct {
		arg1 v1b.ObjectMeta
	}
	setObjectMetaReturns struct {
		result1 k8s.CronJobBuilder
	}
	setObjectMetaReturnsOnCall map[int]struct {
		result1 k8s.CronJobBuilder
	}
	SetObjectMetaBuildStub        func(k8s.HasBuildObjectMeta) k8s.CronJobBuilder
	setObjectMetaBuildMutex       sync.RWMutex
	setObjectMetaBuildArgsForCall []struct {
		arg1 k8s.HasBuildObjectMeta
	}
	setObjectMetaBuildReturns struct {
		result1 k8s.CronJobBuilder
	}
	setObjectMetaBuildReturnsOnCall map[int]struct {
		result1 k8s.CronJobBuilder
	}
	SetParallelismStub        func(int) k8s.CronJobBuilder
	setParallelismMutex       sync.RWMutex
	setParallelismArgsForCall []struct {
		arg1 int
	}
	setParallelismReturns struct {
		result1 k8s.CronJobBuilder
	}
	setParallelismReturnsOnCall map[int]struct {
		result1 k8s.CronJobBuilder
	}
	SetPodSpecStub        func(v1.PodSpec) k8s.CronJobBuilder
	setPodSpecMutex       sync.RWMutex
	setPodSpecArgsForCall []struct {
		arg1 v1.PodSpec
	}
	setPodSpecReturns struct {
		result1 k8s.CronJobBuilder
	}
	setPodSpecReturnsOnCall map[int]struct {
		result1 k8s.CronJobBuilder
	}
	SetPodSpecBuilderStub        func(k8s.HasBuildPodSpec) k8s.CronJobBuilder
	setPodSpecBuilderMutex       sync.RWMutex
	setPodSpecBuilderArgsForCall []struct {
		arg1 k8s.HasBuildPodSpec
	}
	setPodSpecBuilderReturns struct {
		result1 k8s.CronJobBuilder
	}
	setPodSpecBuilderReturnsOnCall map[int]struct {
		result1 k8s.CronJobBuilder
	}
	SetVolumesStub        func([]v1.Volume) k8s.CronJobBuilder
	setVolumesMutex       sync.RWMutex
	setVolumesArgsForCall []struct {
		arg1 []v1.Volume
	}
	setVolumesReturns struct {
		result1 k8s.CronJobBuilder
	}
	setVolumesReturnsOnCall map[int]struct {
		result1 k8s.CronJobBuilder
	}
	ValidateStub        func(context.Context) error
	validateMutex       sync.RWMutex
	validateArgsForCall []struct {
		arg1 context.Context
	}
	validateReturns struct {
		result1 error
	}
	validateReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *K8sCronJobBuilder) AddVolumeMounts(arg1 ...v1.VolumeMount) k8s.CronJobBuilder {
	fake.addVolumeMountsMutex.Lock()
	ret, specificReturn := fake.addVolumeMountsReturnsOnCall[len(fake.addVolumeMountsArgsForCall)]
	fake.addVolumeMountsArgsForCall = append(fake.addVolumeMountsArgsForCall, struct {
		arg1 []v1.VolumeMount
	}{arg1})
	stub := fake.AddVolumeMountsStub
	fakeReturns := fake.addVolumeMountsReturns
	fake.recordInvocation("AddVolumeMounts", []interface{}{arg1})
	fake.addVolumeMountsMutex.Unlock()
	if stub != nil {
		return stub(arg1...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *K8sCronJobBuilder) AddVolumeMountsCallCount() int {
	fake.addVolumeMountsMutex.RLock()
	defer fake.addVolumeMountsMutex.RUnlock()
	return len(fake.addVolumeMountsArgsForCall)
}

func (fake *K8sCronJobBuilder) AddVolumeMountsCalls(stub func(...v1.VolumeMount) k8s.CronJobBuilder) {
	fake.addVolumeMountsMutex.Lock()
	defer fake.addVolumeMountsMutex.Unlock()
	fake.AddVolumeMountsStub = stub
}

func (fake *K8sCronJobBuilder) AddVolumeMountsArgsForCall(i int) []v1.VolumeMount {
	fake.addVolumeMountsMutex.RLock()
	defer fake.addVolumeMountsMutex.RUnlock()
	argsForCall := fake.addVolumeMountsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *K8sCronJobBuilder) AddVolumeMountsReturns(result1 k8s.CronJobBuilder) {
	fake.addVolumeMountsMutex.Lock()
	defer fake.addVolumeMountsMutex.Unlock()
	fake.AddVolumeMountsStub = nil
	fake.addVolumeMountsReturns = struct {
		result1 k8s.CronJobBuilder
	}{result1}
}

func (fake *K8sCronJobBuilder) AddVolumeMountsReturnsOnCall(i int, result1 k8s.CronJobBuilder) {
	fake.addVolumeMountsMutex.Lock()
	defer fake.addVolumeMountsMutex.Unlock()
	fake.AddVolumeMountsStub = nil
	if fake.addVolumeMountsReturnsOnCall == nil {
		fake.addVolumeMountsReturnsOnCall = make(map[int]struct {
			result1 k8s.CronJobBuilder
		})
	}
	fake.addVolumeMountsReturnsOnCall[i] = struct {
		result1 k8s.CronJobBuilder
	}{result1}
}

func (fake *K8sCronJobBuilder) AddVolumes(arg1 ...v1.Volume) k8s.CronJobBuilder {
	fake.addVolumesMutex.Lock()
	ret, specificReturn := fake.addVolumesReturnsOnCall[len(fake.addVolumesArgsForCall)]
	fake.addVolumesArgsForCall = append(fake.addVolumesArgsForCall, struct {
		arg1 []v1.Volume
	}{arg1})
	stub := fake.AddVolumesStub
	fakeReturns := fake.addVolumesReturns
	fake.recordInvocation("AddVolumes", []interface{}{arg1})
	fake.addVolumesMutex.Unlock()
	if stub != nil {
		return stub(arg1...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *K8sCronJobBuilder) AddVolumesCallCount() int {
	fake.addVolumesMutex.RLock()
	defer fake.addVolumesMutex.RUnlock()
	return len(fake.addVolumesArgsForCall)
}

func (fake *K8sCronJobBuilder) AddVolumesCalls(stub func(...v1.Volume) k8s.CronJobBuilder) {
	fake.addVolumesMutex.Lock()
	defer fake.addVolumesMutex.Unlock()
	fake.AddVolumesStub = stub
}

func (fake *K8sCronJobBuilder) AddVolumesArgsForCall(i int) []v1.Volume {
	fake.addVolumesMutex.RLock()
	defer fake.addVolumesMutex.RUnlock()
	argsForCall := fake.addVolumesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *K8sCronJobBuilder) AddVolumesReturns(result1 k8s.CronJobBuilder) {
	fake.addVolumesMutex.Lock()
	defer fake.addVolumesMutex.Unlock()
	fake.AddVolumesStub = nil
	fake.addVolumesReturns = struct {
		result1 k8s.CronJobBuilder
	}{result1}
}

func (fake *K8sCronJobBuilder) AddVolumesReturnsOnCall(i int, result1 k8s.CronJobBuilder) {
	fake.addVolumesMutex.Lock()
	defer fake.addVolumesMutex.Unlock()
	fake.AddVolumesStub = nil
	if fake.addVolumesReturnsOnCall == nil {
		fake.addVolumesReturnsOnCall = make(map[int]struct {
			result1 k8s.CronJobBuilder
		})
	}
	fake.addVolumesReturnsOnCall[i] = struct {
		result1 k8s.CronJobBuilder
	}{result1}
}

func (fake *K8sCronJobBuilder) Build(arg1 context.Context) (*v1a.CronJob, error) {
	fake.buildMutex.Lock()
	ret, specificReturn := fake.buildReturnsOnCall[len(fake.buildArgsForCall)]
	fake.buildArgsForCall = append(fake.buildArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.BuildStub
	fakeReturns := fake.buildReturns
	fake.recordInvocation("Build", []interface{}{arg1})
	fake.buildMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *K8sCronJobBuilder) BuildCallCount() int {
	fake.buildMutex.RLock()
	defer fake.buildMutex.RUnlock()
	return len(fake.buildArgsForCall)
}

func (fake *K8sCronJobBuilder) BuildCalls(stub func(context.Context) (*v1a.CronJob, error)) {
	fake.buildMutex.Lock()
	defer fake.buildMutex.Unlock()
	fake.BuildStub = stub
}

func (fake *K8sCronJobBuilder) BuildArgsForCall(i int) context.Context {
	fake.buildMutex.RLock()
	defer fake.buildMutex.RUnlock()
	argsForCall := fake.buildArgsForCall[i]
	return argsForCall.arg1
}

func (fake *K8sCronJobBuilder) BuildReturns(result1 *v1a.CronJob, result2 error) {
	fake.buildMutex.Lock()
	defer fake.buildMutex.Unlock()
	fake.BuildStub = nil
	fake.buildReturns = struct {
		result1 *v1a.CronJob
		result2 error
	}{result1, result2}
}

func (fake *K8sCronJobBuilder) BuildReturnsOnCall(i int, result1 *v1a.CronJob, result2 error) {
	fake.buildMutex.Lock()
	defer fake.buildMutex.Unlock()
	fake.BuildStub = nil
	if fake.buildReturnsOnCall == nil {
		fake.buildReturnsOnCall = make(map[int]struct {
			result1 *v1a.CronJob
			result2 error
		})
	}
	fake.buildReturnsOnCall[i] = struct {
		result1 *v1a.CronJob
		result2 error
	}{result1, result2}
}

func (fake *K8sCronJobBuilder) SetBackoffLimit(arg1 int) k8s.CronJobBuilder {
	fake.setBackoffLimitMutex.Lock()
	ret, specificReturn := fake.setBackoffLimitReturnsOnCall[len(fake.setBackoffLimitArgsForCall)]
	fake.setBackoffLimitArgsForCall = append(fake.setBackoffLimitArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.SetBackoffLimitStub
	fakeReturns := fake.setBackoffLimitReturns
	fake.recordInvocation("SetBackoffLimit", []interface{}{arg1})
	fake.setBackoffLimitMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *K8sCronJobBuilder) SetBackoffLimitCallCount() int {
	fake.setBackoffLimitMutex.RLock()
	defer fake.setBackoffLimitMutex.RUnlock()
	return len(fake.setBackoffLimitArgsForCall)
}

func (fake *K8sCronJobBuilder) SetBackoffLimitCalls(stub func(int) k8s.CronJobBuilder) {
	fake.setBackoffLimitMutex.Lock()
	defer fake.setBackoffLimitMutex.Unlock()
	fake.SetBackoffLimitStub = stub
}

func (fake *K8sCronJobBuilder) SetBackoffLimitArgsForCall(i int) int {
	fake.setBackoffLimitMutex.RLock()
	defer fake.setBackoffLimitMutex.RUnlock()
	argsForCall := fake.setBackoffLimitArgsForCall[i]
	return argsForCall.arg1
}

func (fake *K8sCronJobBuilder) SetBackoffLimitReturns(result1 k8s.CronJobBuilder) {
	fake.setBackoffLimitMutex.Lock()
	defer fake.setBackoffLimitMutex.Unlock()
	fake.SetBackoffLimitStub = nil
	fake.setBackoffLimitReturns = struct {
		result1 k8s.CronJobBuilder
	}{result1}
}

func (fake *K8sCronJobBuilder) SetBackoffLimitReturnsOnCall(i int, result1 k8s.CronJobBuilder) {
	fake.setBackoffLimitMutex.Lock()
	defer fake.setBackoffLimitMutex.Unlock()
	fake.SetBackoffLimitStub = nil
	if fake.setBackoffLimitReturnsOnCall == nil {
		fake.setBackoffLimitReturnsOnCall = make(map[int]struct {
			result1 k8s.CronJobBuilder
		})
	}
	fake.setBackoffLimitReturnsOnCall[i] = struct {
		result1 k8s.CronJobBuilder
	}{result1}
}

func (fake *K8sCronJobBuilder) SetCompletions(arg1 int) k8s.CronJobBuilder {
	fake.setCompletionsMutex.Lock()
	ret, specificReturn := fake.setCompletionsReturnsOnCall[len(fake.setCompletionsArgsForCall)]
	fake.setCompletionsArgsForCall = append(fake.setCompletionsArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.SetCompletionsStub
	fakeReturns := fake.setCompletionsReturns
	fake.recordInvocation("SetCompletions", []interface{}{arg1})
	fake.setCompletionsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *K8sCronJobBuilder) SetCompletionsCallCount() int {
	fake.setCompletionsMutex.RLock()
	defer fake.setCompletionsMutex.RUnlock()
	return len(fake.setCompletionsArgsForCall)
}

func (fake *K8sCronJobBuilder) SetCompletionsCalls(stub func(int) k8s.CronJobBuilder) {
	fake.setCompletionsMutex.Lock()
	defer fake.setCompletionsMutex.Unlock()
	fake.SetCompletionsStub = stub
}

func (fake *K8sCronJobBuilder) SetCompletionsArgsForCall(i int) int {
	fake.setCompletionsMutex.RLock()
	defer fake.setCompletionsMutex.RUnlock()
	argsForCall := fake.setCompletionsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *K8sCronJobBuilder) SetCompletionsReturns(result1 k8s.CronJobBuilder) {
	fake.setCompletionsMutex.Lock()
	defer fake.setCompletionsMutex.Unlock()
	fake.SetCompletionsStub = nil
	fake.setCompletionsReturns = struct {
		result1 k8s.CronJobBuilder
	}{result1}
}

func (fake *K8sCronJobBuilder) SetCompletionsReturnsOnCall(i int, result1 k8s.CronJobBuilder) {
	fake.setCompletionsMutex.Lock()
	defer fake.setCompletionsMutex.Unlock()
	fake.SetCompletionsStub = nil
	if fake.setCompletionsReturnsOnCall == nil {
		fake.setCompletionsReturnsOnCall = make(map[int]struct {
			result1 k8s.CronJobBuilder
		})
	}
	fake.setCompletionsReturnsOnCall[i] = struct {
		result1 k8s.CronJobBuilder
	}{result1}
}

func (fake *K8sCronJobBuilder) SetCronExpression(arg1 k8s.CronScheduleExpression) k8s.CronJobBuilder {
	fake.setCronExpressionMutex.Lock()
	ret, specificReturn := fake.setCronExpressionReturnsOnCall[len(fake.setCronExpressionArgsForCall)]
	fake.setCronExpressionArgsForCall = append(fake.setCronExpressionArgsForCall, struct {
		arg1 k8s.CronScheduleExpression
	}{arg1})
	stub := fake.SetCronExpressionStub
	fakeReturns := fake.setCronExpressionReturns
	fake.recordInvocation("SetCronExpression", []interface{}{arg1})
	fake.setCronExpressionMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *K8sCronJobBuilder) SetCronExpressionCallCount() int {
	fake.setCronExpressionMutex.RLock()
	defer fake.setCronExpressionMutex.RUnlock()
	return len(fake.setCronExpressionArgsForCall)
}

func (fake *K8sCronJobBuilder) SetCronExpressionCalls(stub func(k8s.CronScheduleExpression) k8s.CronJobBuilder) {
	fake.setCronExpressionMutex.Lock()
	defer fake.setCronExpressionMutex.Unlock()
	fake.SetCronExpressionStub = stub
}

func (fake *K8sCronJobBuilder) SetCronExpressionArgsForCall(i int) k8s.CronScheduleExpression {
	fake.setCronExpressionMutex.RLock()
	defer fake.setCronExpressionMutex.RUnlock()
	argsForCall := fake.setCronExpressionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *K8sCronJobBuilder) SetCronExpressionReturns(result1 k8s.CronJobBuilder) {
	fake.setCronExpressionMutex.Lock()
	defer fake.setCronExpressionMutex.Unlock()
	fake.SetCronExpressionStub = nil
	fake.setCronExpressionReturns = struct {
		result1 k8s.CronJobBuilder
	}{result1}
}

func (fake *K8sCronJobBuilder) SetCronExpressionReturnsOnCall(i int, result1 k8s.CronJobBuilder) {
	fake.setCronExpressionMutex.Lock()
	defer fake.setCronExpressionMutex.Unlock()
	fake.SetCronExpressionStub = nil
	if fake.setCronExpressionReturnsOnCall == nil {
		fake.setCronExpressionReturnsOnCall = make(map[int]struct {
			result1 k8s.CronJobBuilder
		})
	}
	fake.setCronExpressionReturnsOnCall[i] = struct {
		result1 k8s.CronJobBuilder
	}{result1}
}

func (fake *K8sCronJobBuilder) SetEnv(arg1 []v1.EnvVar) k8s.CronJobBuilder {
	var arg1Copy []v1.EnvVar
	if arg1 != nil {
		arg1Copy = make([]v1.EnvVar, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.setEnvMutex.Lock()
	ret, specificReturn := fake.setEnvReturnsOnCall[len(fake.setEnvArgsForCall)]
	fake.setEnvArgsForCall = append(fake.setEnvArgsForCall, struct {
		arg1 []v1.EnvVar
	}{arg1Copy})
	stub := fake.SetEnvStub
	fakeReturns := fake.setEnvReturns
	fake.recordInvocation("SetEnv", []interface{}{arg1Copy})
	fake.setEnvMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *K8sCronJobBuilder) SetEnvCallCount() int {
	fake.setEnvMutex.RLock()
	defer fake.setEnvMutex.RUnlock()
	return len(fake.setEnvArgsForCall)
}

func (fake *K8sCronJobBuilder) SetEnvCalls(stub func([]v1.EnvVar) k8s.CronJobBuilder) {
	fake.setEnvMutex.Lock()
	defer fake.setEnvMutex.Unlock()
	fake.SetEnvStub = stub
}

func (fake *K8sCronJobBuilder) SetEnvArgsForCall(i int) []v1.EnvVar {
	fake.setEnvMutex.RLock()
	defer fake.setEnvMutex.RUnlock()
	argsForCall := fake.setEnvArgsForCall[i]
	return argsForCall.arg1
}

func (fake *K8sCronJobBuilder) SetEnvReturns(result1 k8s.CronJobBuilder) {
	fake.setEnvMutex.Lock()
	defer fake.setEnvMutex.Unlock()
	fake.SetEnvStub = nil
	fake.setEnvReturns = struct {
		result1 k8s.CronJobBuilder
	}{result1}
}

func (fake *K8sCronJobBuilder) SetEnvReturnsOnCall(i int, result1 k8s.CronJobBuilder) {
	fake.setEnvMutex.Lock()
	defer fake.setEnvMutex.Unlock()
	fake.SetEnvStub = nil
	if fake.setEnvReturnsOnCall == nil {
		fake.setEnvReturnsOnCall = make(map[int]struct {
			result1 k8s.CronJobBuilder
		})
	}
	fake.setEnvReturnsOnCall[i] = struct {
		result1 k8s.CronJobBuilder
	}{result1}
}

func (fake *K8sCronJobBuilder) SetImage(arg1 string) k8s.CronJobBuilder {
	fake.setImageMutex.Lock()
	ret, specificReturn := fake.setImageReturnsOnCall[len(fake.setImageArgsForCall)]
	fake.setImageArgsForCall = append(fake.setImageArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.SetImageStub
	fakeReturns := fake.setImageReturns
	fake.recordInvocation("SetImage", []interface{}{arg1})
	fake.setImageMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *K8sCronJobBuilder) SetImageCallCount() int {
	fake.setImageMutex.RLock()
	defer fake.setImageMutex.RUnlock()
	return len(fake.setImageArgsForCall)
}

func (fake *K8sCronJobBuilder) SetImageCalls(stub func(string) k8s.CronJobBuilder) {
	fake.setImageMutex.Lock()
	defer fake.setImageMutex.Unlock()
	fake.SetImageStub = stub
}

func (fake *K8sCronJobBuilder) SetImageArgsForCall(i int) string {
	fake.setImageMutex.RLock()
	defer fake.setImageMutex.RUnlock()
	argsForCall := fake.setImageArgsForCall[i]
	return argsForCall.arg1
}

func (fake *K8sCronJobBuilder) SetImageReturns(result1 k8s.CronJobBuilder) {
	fake.setImageMutex.Lock()
	defer fake.setImageMutex.Unlock()
	fake.SetImageStub = nil
	fake.setImageReturns = struct {
		result1 k8s.CronJobBuilder
	}{result1}
}

func (fake *K8sCronJobBuilder) SetImageReturnsOnCall(i int, result1 k8s.CronJobBuilder) {
	fake.setImageMutex.Lock()
	defer fake.setImageMutex.Unlock()
	fake.SetImageStub = nil
	if fake.setImageReturnsOnCall == nil {
		fake.setImageReturnsOnCall = make(map[int]struct {
			result1 k8s.CronJobBuilder
		})
	}
	fake.setImageReturnsOnCall[i] = struct {
		result1 k8s.CronJobBuilder
	}{result1}
}

func (fake *K8sCronJobBuilder) SetLoglevel(arg1 int) k8s.CronJobBuilder {
	fake.setLoglevelMutex.Lock()
	ret, specificReturn := fake.setLoglevelReturnsOnCall[len(fake.setLoglevelArgsForCall)]
	fake.setLoglevelArgsForCall = append(fake.setLoglevelArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.SetLoglevelStub
	fakeReturns := fake.setLoglevelReturns
	fake.recordInvocation("SetLoglevel", []interface{}{arg1})
	fake.setLoglevelMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *K8sCronJobBuilder) SetLoglevelCallCount() int {
	fake.setLoglevelMutex.RLock()
	defer fake.setLoglevelMutex.RUnlock()
	return len(fake.setLoglevelArgsForCall)
}

func (fake *K8sCronJobBuilder) SetLoglevelCalls(stub func(int) k8s.CronJobBuilder) {
	fake.setLoglevelMutex.Lock()
	defer fake.setLoglevelMutex.Unlock()
	fake.SetLoglevelStub = stub
}

func (fake *K8sCronJobBuilder) SetLoglevelArgsForCall(i int) int {
	fake.setLoglevelMutex.RLock()
	defer fake.setLoglevelMutex.RUnlock()
	argsForCall := fake.setLoglevelArgsForCall[i]
	return argsForCall.arg1
}

func (fake *K8sCronJobBuilder) SetLoglevelReturns(result1 k8s.CronJobBuilder) {
	fake.setLoglevelMutex.Lock()
	defer fake.setLoglevelMutex.Unlock()
	fake.SetLoglevelStub = nil
	fake.setLoglevelReturns = struct {
		result1 k8s.CronJobBuilder
	}{result1}
}

func (fake *K8sCronJobBuilder) SetLoglevelReturnsOnCall(i int, result1 k8s.CronJobBuilder) {
	fake.setLoglevelMutex.Lock()
	defer fake.setLoglevelMutex.Unlock()
	fake.SetLoglevelStub = nil
	if fake.setLoglevelReturnsOnCall == nil {
		fake.setLoglevelReturnsOnCall = make(map[int]struct {
			result1 k8s.CronJobBuilder
		})
	}
	fake.setLoglevelReturnsOnCall[i] = struct {
		result1 k8s.CronJobBuilder
	}{result1}
}

func (fake *K8sCronJobBuilder) SetObjectMeta(arg1 v1b.ObjectMeta) k8s.CronJobBuilder {
	fake.setObjectMetaMutex.Lock()
	ret, specificReturn := fake.setObjectMetaReturnsOnCall[len(fake.setObjectMetaArgsForCall)]
	fake.setObjectMetaArgsForCall = append(fake.setObjectMetaArgsForCall, struct {
		arg1 v1b.ObjectMeta
	}{arg1})
	stub := fake.SetObjectMetaStub
	fakeReturns := fake.setObjectMetaReturns
	fake.recordInvocation("SetObjectMeta", []interface{}{arg1})
	fake.setObjectMetaMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *K8sCronJobBuilder) SetObjectMetaCallCount() int {
	fake.setObjectMetaMutex.RLock()
	defer fake.setObjectMetaMutex.RUnlock()
	return len(fake.setObjectMetaArgsForCall)
}

func (fake *K8sCronJobBuilder) SetObjectMetaCalls(stub func(v1b.ObjectMeta) k8s.CronJobBuilder) {
	fake.setObjectMetaMutex.Lock()
	defer fake.setObjectMetaMutex.Unlock()
	fake.SetObjectMetaStub = stub
}

func (fake *K8sCronJobBuilder) SetObjectMetaArgsForCall(i int) v1b.ObjectMeta {
	fake.setObjectMetaMutex.RLock()
	defer fake.setObjectMetaMutex.RUnlock()
	argsForCall := fake.setObjectMetaArgsForCall[i]
	return argsForCall.arg1
}

func (fake *K8sCronJobBuilder) SetObjectMetaReturns(result1 k8s.CronJobBuilder) {
	fake.setObjectMetaMutex.Lock()
	defer fake.setObjectMetaMutex.Unlock()
	fake.SetObjectMetaStub = nil
	fake.setObjectMetaReturns = struct {
		result1 k8s.CronJobBuilder
	}{result1}
}

func (fake *K8sCronJobBuilder) SetObjectMetaReturnsOnCall(i int, result1 k8s.CronJobBuilder) {
	fake.setObjectMetaMutex.Lock()
	defer fake.setObjectMetaMutex.Unlock()
	fake.SetObjectMetaStub = nil
	if fake.setObjectMetaReturnsOnCall == nil {
		fake.setObjectMetaReturnsOnCall = make(map[int]struct {
			result1 k8s.CronJobBuilder
		})
	}
	fake.setObjectMetaReturnsOnCall[i] = struct {
		result1 k8s.CronJobBuilder
	}{result1}
}

func (fake *K8sCronJobBuilder) SetObjectMetaBuild(arg1 k8s.HasBuildObjectMeta) k8s.CronJobBuilder {
	fake.setObjectMetaBuildMutex.Lock()
	ret, specificReturn := fake.setObjectMetaBuildReturnsOnCall[len(fake.setObjectMetaBuildArgsForCall)]
	fake.setObjectMetaBuildArgsForCall = append(fake.setObjectMetaBuildArgsForCall, struct {
		arg1 k8s.HasBuildObjectMeta
	}{arg1})
	stub := fake.SetObjectMetaBuildStub
	fakeReturns := fake.setObjectMetaBuildReturns
	fake.recordInvocation("SetObjectMetaBuild", []interface{}{arg1})
	fake.setObjectMetaBuildMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *K8sCronJobBuilder) SetObjectMetaBuildCallCount() int {
	fake.setObjectMetaBuildMutex.RLock()
	defer fake.setObjectMetaBuildMutex.RUnlock()
	return len(fake.setObjectMetaBuildArgsForCall)
}

func (fake *K8sCronJobBuilder) SetObjectMetaBuildCalls(stub func(k8s.HasBuildObjectMeta) k8s.CronJobBuilder) {
	fake.setObjectMetaBuildMutex.Lock()
	defer fake.setObjectMetaBuildMutex.Unlock()
	fake.SetObjectMetaBuildStub = stub
}

func (fake *K8sCronJobBuilder) SetObjectMetaBuildArgsForCall(i int) k8s.HasBuildObjectMeta {
	fake.setObjectMetaBuildMutex.RLock()
	defer fake.setObjectMetaBuildMutex.RUnlock()
	argsForCall := fake.setObjectMetaBuildArgsForCall[i]
	return argsForCall.arg1
}

func (fake *K8sCronJobBuilder) SetObjectMetaBuildReturns(result1 k8s.CronJobBuilder) {
	fake.setObjectMetaBuildMutex.Lock()
	defer fake.setObjectMetaBuildMutex.Unlock()
	fake.SetObjectMetaBuildStub = nil
	fake.setObjectMetaBuildReturns = struct {
		result1 k8s.CronJobBuilder
	}{result1}
}

func (fake *K8sCronJobBuilder) SetObjectMetaBuildReturnsOnCall(i int, result1 k8s.CronJobBuilder) {
	fake.setObjectMetaBuildMutex.Lock()
	defer fake.setObjectMetaBuildMutex.Unlock()
	fake.SetObjectMetaBuildStub = nil
	if fake.setObjectMetaBuildReturnsOnCall == nil {
		fake.setObjectMetaBuildReturnsOnCall = make(map[int]struct {
			result1 k8s.CronJobBuilder
		})
	}
	fake.setObjectMetaBuildReturnsOnCall[i] = struct {
		result1 k8s.CronJobBuilder
	}{result1}
}

func (fake *K8sCronJobBuilder) SetParallelism(arg1 int) k8s.CronJobBuilder {
	fake.setParallelismMutex.Lock()
	ret, specificReturn := fake.setParallelismReturnsOnCall[len(fake.setParallelismArgsForCall)]
	fake.setParallelismArgsForCall = append(fake.setParallelismArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.SetParallelismStub
	fakeReturns := fake.setParallelismReturns
	fake.recordInvocation("SetParallelism", []interface{}{arg1})
	fake.setParallelismMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *K8sCronJobBuilder) SetParallelismCallCount() int {
	fake.setParallelismMutex.RLock()
	defer fake.setParallelismMutex.RUnlock()
	return len(fake.setParallelismArgsForCall)
}

func (fake *K8sCronJobBuilder) SetParallelismCalls(stub func(int) k8s.CronJobBuilder) {
	fake.setParallelismMutex.Lock()
	defer fake.setParallelismMutex.Unlock()
	fake.SetParallelismStub = stub
}

func (fake *K8sCronJobBuilder) SetParallelismArgsForCall(i int) int {
	fake.setParallelismMutex.RLock()
	defer fake.setParallelismMutex.RUnlock()
	argsForCall := fake.setParallelismArgsForCall[i]
	return argsForCall.arg1
}

func (fake *K8sCronJobBuilder) SetParallelismReturns(result1 k8s.CronJobBuilder) {
	fake.setParallelismMutex.Lock()
	defer fake.setParallelismMutex.Unlock()
	fake.SetParallelismStub = nil
	fake.setParallelismReturns = struct {
		result1 k8s.CronJobBuilder
	}{result1}
}

func (fake *K8sCronJobBuilder) SetParallelismReturnsOnCall(i int, result1 k8s.CronJobBuilder) {
	fake.setParallelismMutex.Lock()
	defer fake.setParallelismMutex.Unlock()
	fake.SetParallelismStub = nil
	if fake.setParallelismReturnsOnCall == nil {
		fake.setParallelismReturnsOnCall = make(map[int]struct {
			result1 k8s.CronJobBuilder
		})
	}
	fake.setParallelismReturnsOnCall[i] = struct {
		result1 k8s.CronJobBuilder
	}{result1}
}

func (fake *K8sCronJobBuilder) SetPodSpec(arg1 v1.PodSpec) k8s.CronJobBuilder {
	fake.setPodSpecMutex.Lock()
	ret, specificReturn := fake.setPodSpecReturnsOnCall[len(fake.setPodSpecArgsForCall)]
	fake.setPodSpecArgsForCall = append(fake.setPodSpecArgsForCall, struct {
		arg1 v1.PodSpec
	}{arg1})
	stub := fake.SetPodSpecStub
	fakeReturns := fake.setPodSpecReturns
	fake.recordInvocation("SetPodSpec", []interface{}{arg1})
	fake.setPodSpecMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *K8sCronJobBuilder) SetPodSpecCallCount() int {
	fake.setPodSpecMutex.RLock()
	defer fake.setPodSpecMutex.RUnlock()
	return len(fake.setPodSpecArgsForCall)
}

func (fake *K8sCronJobBuilder) SetPodSpecCalls(stub func(v1.PodSpec) k8s.CronJobBuilder) {
	fake.setPodSpecMutex.Lock()
	defer fake.setPodSpecMutex.Unlock()
	fake.SetPodSpecStub = stub
}

func (fake *K8sCronJobBuilder) SetPodSpecArgsForCall(i int) v1.PodSpec {
	fake.setPodSpecMutex.RLock()
	defer fake.setPodSpecMutex.RUnlock()
	argsForCall := fake.setPodSpecArgsForCall[i]
	return argsForCall.arg1
}

func (fake *K8sCronJobBuilder) SetPodSpecReturns(result1 k8s.CronJobBuilder) {
	fake.setPodSpecMutex.Lock()
	defer fake.setPodSpecMutex.Unlock()
	fake.SetPodSpecStub = nil
	fake.setPodSpecReturns = struct {
		result1 k8s.CronJobBuilder
	}{result1}
}

func (fake *K8sCronJobBuilder) SetPodSpecReturnsOnCall(i int, result1 k8s.CronJobBuilder) {
	fake.setPodSpecMutex.Lock()
	defer fake.setPodSpecMutex.Unlock()
	fake.SetPodSpecStub = nil
	if fake.setPodSpecReturnsOnCall == nil {
		fake.setPodSpecReturnsOnCall = make(map[int]struct {
			result1 k8s.CronJobBuilder
		})
	}
	fake.setPodSpecReturnsOnCall[i] = struct {
		result1 k8s.CronJobBuilder
	}{result1}
}

func (fake *K8sCronJobBuilder) SetPodSpecBuilder(arg1 k8s.HasBuildPodSpec) k8s.CronJobBuilder {
	fake.setPodSpecBuilderMutex.Lock()
	ret, specificReturn := fake.setPodSpecBuilderReturnsOnCall[len(fake.setPodSpecBuilderArgsForCall)]
	fake.setPodSpecBuilderArgsForCall = append(fake.setPodSpecBuilderArgsForCall, struct {
		arg1 k8s.HasBuildPodSpec
	}{arg1})
	stub := fake.SetPodSpecBuilderStub
	fakeReturns := fake.setPodSpecBuilderReturns
	fake.recordInvocation("SetPodSpecBuilder", []interface{}{arg1})
	fake.setPodSpecBuilderMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *K8sCronJobBuilder) SetPodSpecBuilderCallCount() int {
	fake.setPodSpecBuilderMutex.RLock()
	defer fake.setPodSpecBuilderMutex.RUnlock()
	return len(fake.setPodSpecBuilderArgsForCall)
}

func (fake *K8sCronJobBuilder) SetPodSpecBuilderCalls(stub func(k8s.HasBuildPodSpec) k8s.CronJobBuilder) {
	fake.setPodSpecBuilderMutex.Lock()
	defer fake.setPodSpecBuilderMutex.Unlock()
	fake.SetPodSpecBuilderStub = stub
}

func (fake *K8sCronJobBuilder) SetPodSpecBuilderArgsForCall(i int) k8s.HasBuildPodSpec {
	fake.setPodSpecBuilderMutex.RLock()
	defer fake.setPodSpecBuilderMutex.RUnlock()
	argsForCall := fake.setPodSpecBuilderArgsForCall[i]
	return argsForCall.arg1
}

func (fake *K8sCronJobBuilder) SetPodSpecBuilderReturns(result1 k8s.CronJobBuilder) {
	fake.setPodSpecBuilderMutex.Lock()
	defer fake.setPodSpecBuilderMutex.Unlock()
	fake.SetPodSpecBuilderStub = nil
	fake.setPodSpecBuilderReturns = struct {
		result1 k8s.CronJobBuilder
	}{result1}
}

func (fake *K8sCronJobBuilder) SetPodSpecBuilderReturnsOnCall(i int, result1 k8s.CronJobBuilder) {
	fake.setPodSpecBuilderMutex.Lock()
	defer fake.setPodSpecBuilderMutex.Unlock()
	fake.SetPodSpecBuilderStub = nil
	if fake.setPodSpecBuilderReturnsOnCall == nil {
		fake.setPodSpecBuilderReturnsOnCall = make(map[int]struct {
			result1 k8s.CronJobBuilder
		})
	}
	fake.setPodSpecBuilderReturnsOnCall[i] = struct {
		result1 k8s.CronJobBuilder
	}{result1}
}

func (fake *K8sCronJobBuilder) SetVolumes(arg1 []v1.Volume) k8s.CronJobBuilder {
	var arg1Copy []v1.Volume
	if arg1 != nil {
		arg1Copy = make([]v1.Volume, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.setVolumesMutex.Lock()
	ret, specificReturn := fake.setVolumesReturnsOnCall[len(fake.setVolumesArgsForCall)]
	fake.setVolumesArgsForCall = append(fake.setVolumesArgsForCall, struct {
		arg1 []v1.Volume
	}{arg1Copy})
	stub := fake.SetVolumesStub
	fakeReturns := fake.setVolumesReturns
	fake.recordInvocation("SetVolumes", []interface{}{arg1Copy})
	fake.setVolumesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *K8sCronJobBuilder) SetVolumesCallCount() int {
	fake.setVolumesMutex.RLock()
	defer fake.setVolumesMutex.RUnlock()
	return len(fake.setVolumesArgsForCall)
}

func (fake *K8sCronJobBuilder) SetVolumesCalls(stub func([]v1.Volume) k8s.CronJobBuilder) {
	fake.setVolumesMutex.Lock()
	defer fake.setVolumesMutex.Unlock()
	fake.SetVolumesStub = stub
}

func (fake *K8sCronJobBuilder) SetVolumesArgsForCall(i int) []v1.Volume {
	fake.setVolumesMutex.RLock()
	defer fake.setVolumesMutex.RUnlock()
	argsForCall := fake.setVolumesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *K8sCronJobBuilder) SetVolumesReturns(result1 k8s.CronJobBuilder) {
	fake.setVolumesMutex.Lock()
	defer fake.setVolumesMutex.Unlock()
	fake.SetVolumesStub = nil
	fake.setVolumesReturns = struct {
		result1 k8s.CronJobBuilder
	}{result1}
}

func (fake *K8sCronJobBuilder) SetVolumesReturnsOnCall(i int, result1 k8s.CronJobBuilder) {
	fake.setVolumesMutex.Lock()
	defer fake.setVolumesMutex.Unlock()
	fake.SetVolumesStub = nil
	if fake.setVolumesReturnsOnCall == nil {
		fake.setVolumesReturnsOnCall = make(map[int]struct {
			result1 k8s.CronJobBuilder
		})
	}
	fake.setVolumesReturnsOnCall[i] = struct {
		result1 k8s.CronJobBuilder
	}{result1}
}

func (fake *K8sCronJobBuilder) Validate(arg1 context.Context) error {
	fake.validateMutex.Lock()
	ret, specificReturn := fake.validateReturnsOnCall[len(fake.validateArgsForCall)]
	fake.validateArgsForCall = append(fake.validateArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.ValidateStub
	fakeReturns := fake.validateReturns
	fake.recordInvocation("Validate", []interface{}{arg1})
	fake.validateMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *K8sCronJobBuilder) ValidateCallCount() int {
	fake.validateMutex.RLock()
	defer fake.validateMutex.RUnlock()
	return len(fake.validateArgsForCall)
}

func (fake *K8sCronJobBuilder) ValidateCalls(stub func(context.Context) error) {
	fake.validateMutex.Lock()
	defer fake.validateMutex.Unlock()
	fake.ValidateStub = stub
}

func (fake *K8sCronJobBuilder) ValidateArgsForCall(i int) context.Context {
	fake.validateMutex.RLock()
	defer fake.validateMutex.RUnlock()
	argsForCall := fake.validateArgsForCall[i]
	return argsForCall.arg1
}

func (fake *K8sCronJobBuilder) ValidateReturns(result1 error) {
	fake.validateMutex.Lock()
	defer fake.validateMutex.Unlock()
	fake.ValidateStub = nil
	fake.validateReturns = struct {
		result1 error
	}{result1}
}

func (fake *K8sCronJobBuilder) ValidateReturnsOnCall(i int, result1 error) {
	fake.validateMutex.Lock()
	defer fake.validateMutex.Unlock()
	fake.ValidateStub = nil
	if fake.validateReturnsOnCall == nil {
		fake.validateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.validateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *K8sCronJobBuilder) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *K8sCronJobBuilder) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ k8s.CronJobBuilder = new(K8sCronJobBuilder)
