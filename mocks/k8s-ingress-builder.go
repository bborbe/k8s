// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"context"
	"sync"

	"github.com/bborbe/k8s"
	v1 "k8s.io/api/networking/v1"
)

type K8sIngressBuilder struct {
	BuildStub        func(context.Context) (*v1.Ingress, error)
	buildMutex       sync.RWMutex
	buildArgsForCall []struct {
		arg1 context.Context
	}
	buildReturns struct {
		result1 *v1.Ingress
		result2 error
	}
	buildReturnsOnCall map[int]struct {
		result1 *v1.Ingress
		result2 error
	}
	SetHostStub        func(string) k8s.IngressBuilder
	setHostMutex       sync.RWMutex
	setHostArgsForCall []struct {
		arg1 string
	}
	setHostReturns struct {
		result1 k8s.IngressBuilder
	}
	setHostReturnsOnCall map[int]struct {
		result1 k8s.IngressBuilder
	}
	SetIngressClassNameStub        func(string) k8s.IngressBuilder
	setIngressClassNameMutex       sync.RWMutex
	setIngressClassNameArgsForCall []struct {
		arg1 string
	}
	setIngressClassNameReturns struct {
		result1 k8s.IngressBuilder
	}
	setIngressClassNameReturnsOnCall map[int]struct {
		result1 k8s.IngressBuilder
	}
	SetObjectMetaBuilderStub        func(k8s.ObjectMetaBuilder) k8s.IngressBuilder
	setObjectMetaBuilderMutex       sync.RWMutex
	setObjectMetaBuilderArgsForCall []struct {
		arg1 k8s.ObjectMetaBuilder
	}
	setObjectMetaBuilderReturns struct {
		result1 k8s.IngressBuilder
	}
	setObjectMetaBuilderReturnsOnCall map[int]struct {
		result1 k8s.IngressBuilder
	}
	SetPathStub        func(string) k8s.IngressBuilder
	setPathMutex       sync.RWMutex
	setPathArgsForCall []struct {
		arg1 string
	}
	setPathReturns struct {
		result1 k8s.IngressBuilder
	}
	setPathReturnsOnCall map[int]struct {
		result1 k8s.IngressBuilder
	}
	SetServiceNameStub        func(k8s.Name) k8s.IngressBuilder
	setServiceNameMutex       sync.RWMutex
	setServiceNameArgsForCall []struct {
		arg1 k8s.Name
	}
	setServiceNameReturns struct {
		result1 k8s.IngressBuilder
	}
	setServiceNameReturnsOnCall map[int]struct {
		result1 k8s.IngressBuilder
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *K8sIngressBuilder) Build(arg1 context.Context) (*v1.Ingress, error) {
	fake.buildMutex.Lock()
	ret, specificReturn := fake.buildReturnsOnCall[len(fake.buildArgsForCall)]
	fake.buildArgsForCall = append(fake.buildArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.BuildStub
	fakeReturns := fake.buildReturns
	fake.recordInvocation("Build", []interface{}{arg1})
	fake.buildMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *K8sIngressBuilder) BuildCallCount() int {
	fake.buildMutex.RLock()
	defer fake.buildMutex.RUnlock()
	return len(fake.buildArgsForCall)
}

func (fake *K8sIngressBuilder) BuildCalls(stub func(context.Context) (*v1.Ingress, error)) {
	fake.buildMutex.Lock()
	defer fake.buildMutex.Unlock()
	fake.BuildStub = stub
}

func (fake *K8sIngressBuilder) BuildArgsForCall(i int) context.Context {
	fake.buildMutex.RLock()
	defer fake.buildMutex.RUnlock()
	argsForCall := fake.buildArgsForCall[i]
	return argsForCall.arg1
}

func (fake *K8sIngressBuilder) BuildReturns(result1 *v1.Ingress, result2 error) {
	fake.buildMutex.Lock()
	defer fake.buildMutex.Unlock()
	fake.BuildStub = nil
	fake.buildReturns = struct {
		result1 *v1.Ingress
		result2 error
	}{result1, result2}
}

func (fake *K8sIngressBuilder) BuildReturnsOnCall(i int, result1 *v1.Ingress, result2 error) {
	fake.buildMutex.Lock()
	defer fake.buildMutex.Unlock()
	fake.BuildStub = nil
	if fake.buildReturnsOnCall == nil {
		fake.buildReturnsOnCall = make(map[int]struct {
			result1 *v1.Ingress
			result2 error
		})
	}
	fake.buildReturnsOnCall[i] = struct {
		result1 *v1.Ingress
		result2 error
	}{result1, result2}
}

func (fake *K8sIngressBuilder) SetHost(arg1 string) k8s.IngressBuilder {
	fake.setHostMutex.Lock()
	ret, specificReturn := fake.setHostReturnsOnCall[len(fake.setHostArgsForCall)]
	fake.setHostArgsForCall = append(fake.setHostArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.SetHostStub
	fakeReturns := fake.setHostReturns
	fake.recordInvocation("SetHost", []interface{}{arg1})
	fake.setHostMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *K8sIngressBuilder) SetHostCallCount() int {
	fake.setHostMutex.RLock()
	defer fake.setHostMutex.RUnlock()
	return len(fake.setHostArgsForCall)
}

func (fake *K8sIngressBuilder) SetHostCalls(stub func(string) k8s.IngressBuilder) {
	fake.setHostMutex.Lock()
	defer fake.setHostMutex.Unlock()
	fake.SetHostStub = stub
}

func (fake *K8sIngressBuilder) SetHostArgsForCall(i int) string {
	fake.setHostMutex.RLock()
	defer fake.setHostMutex.RUnlock()
	argsForCall := fake.setHostArgsForCall[i]
	return argsForCall.arg1
}

func (fake *K8sIngressBuilder) SetHostReturns(result1 k8s.IngressBuilder) {
	fake.setHostMutex.Lock()
	defer fake.setHostMutex.Unlock()
	fake.SetHostStub = nil
	fake.setHostReturns = struct {
		result1 k8s.IngressBuilder
	}{result1}
}

func (fake *K8sIngressBuilder) SetHostReturnsOnCall(i int, result1 k8s.IngressBuilder) {
	fake.setHostMutex.Lock()
	defer fake.setHostMutex.Unlock()
	fake.SetHostStub = nil
	if fake.setHostReturnsOnCall == nil {
		fake.setHostReturnsOnCall = make(map[int]struct {
			result1 k8s.IngressBuilder
		})
	}
	fake.setHostReturnsOnCall[i] = struct {
		result1 k8s.IngressBuilder
	}{result1}
}

func (fake *K8sIngressBuilder) SetIngressClassName(arg1 string) k8s.IngressBuilder {
	fake.setIngressClassNameMutex.Lock()
	ret, specificReturn := fake.setIngressClassNameReturnsOnCall[len(fake.setIngressClassNameArgsForCall)]
	fake.setIngressClassNameArgsForCall = append(fake.setIngressClassNameArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.SetIngressClassNameStub
	fakeReturns := fake.setIngressClassNameReturns
	fake.recordInvocation("SetIngressClassName", []interface{}{arg1})
	fake.setIngressClassNameMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *K8sIngressBuilder) SetIngressClassNameCallCount() int {
	fake.setIngressClassNameMutex.RLock()
	defer fake.setIngressClassNameMutex.RUnlock()
	return len(fake.setIngressClassNameArgsForCall)
}

func (fake *K8sIngressBuilder) SetIngressClassNameCalls(stub func(string) k8s.IngressBuilder) {
	fake.setIngressClassNameMutex.Lock()
	defer fake.setIngressClassNameMutex.Unlock()
	fake.SetIngressClassNameStub = stub
}

func (fake *K8sIngressBuilder) SetIngressClassNameArgsForCall(i int) string {
	fake.setIngressClassNameMutex.RLock()
	defer fake.setIngressClassNameMutex.RUnlock()
	argsForCall := fake.setIngressClassNameArgsForCall[i]
	return argsForCall.arg1
}

func (fake *K8sIngressBuilder) SetIngressClassNameReturns(result1 k8s.IngressBuilder) {
	fake.setIngressClassNameMutex.Lock()
	defer fake.setIngressClassNameMutex.Unlock()
	fake.SetIngressClassNameStub = nil
	fake.setIngressClassNameReturns = struct {
		result1 k8s.IngressBuilder
	}{result1}
}

func (fake *K8sIngressBuilder) SetIngressClassNameReturnsOnCall(i int, result1 k8s.IngressBuilder) {
	fake.setIngressClassNameMutex.Lock()
	defer fake.setIngressClassNameMutex.Unlock()
	fake.SetIngressClassNameStub = nil
	if fake.setIngressClassNameReturnsOnCall == nil {
		fake.setIngressClassNameReturnsOnCall = make(map[int]struct {
			result1 k8s.IngressBuilder
		})
	}
	fake.setIngressClassNameReturnsOnCall[i] = struct {
		result1 k8s.IngressBuilder
	}{result1}
}

func (fake *K8sIngressBuilder) SetObjectMetaBuilder(arg1 k8s.ObjectMetaBuilder) k8s.IngressBuilder {
	fake.setObjectMetaBuilderMutex.Lock()
	ret, specificReturn := fake.setObjectMetaBuilderReturnsOnCall[len(fake.setObjectMetaBuilderArgsForCall)]
	fake.setObjectMetaBuilderArgsForCall = append(fake.setObjectMetaBuilderArgsForCall, struct {
		arg1 k8s.ObjectMetaBuilder
	}{arg1})
	stub := fake.SetObjectMetaBuilderStub
	fakeReturns := fake.setObjectMetaBuilderReturns
	fake.recordInvocation("SetObjectMetaBuilder", []interface{}{arg1})
	fake.setObjectMetaBuilderMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *K8sIngressBuilder) SetObjectMetaBuilderCallCount() int {
	fake.setObjectMetaBuilderMutex.RLock()
	defer fake.setObjectMetaBuilderMutex.RUnlock()
	return len(fake.setObjectMetaBuilderArgsForCall)
}

func (fake *K8sIngressBuilder) SetObjectMetaBuilderCalls(stub func(k8s.ObjectMetaBuilder) k8s.IngressBuilder) {
	fake.setObjectMetaBuilderMutex.Lock()
	defer fake.setObjectMetaBuilderMutex.Unlock()
	fake.SetObjectMetaBuilderStub = stub
}

func (fake *K8sIngressBuilder) SetObjectMetaBuilderArgsForCall(i int) k8s.ObjectMetaBuilder {
	fake.setObjectMetaBuilderMutex.RLock()
	defer fake.setObjectMetaBuilderMutex.RUnlock()
	argsForCall := fake.setObjectMetaBuilderArgsForCall[i]
	return argsForCall.arg1
}

func (fake *K8sIngressBuilder) SetObjectMetaBuilderReturns(result1 k8s.IngressBuilder) {
	fake.setObjectMetaBuilderMutex.Lock()
	defer fake.setObjectMetaBuilderMutex.Unlock()
	fake.SetObjectMetaBuilderStub = nil
	fake.setObjectMetaBuilderReturns = struct {
		result1 k8s.IngressBuilder
	}{result1}
}

func (fake *K8sIngressBuilder) SetObjectMetaBuilderReturnsOnCall(i int, result1 k8s.IngressBuilder) {
	fake.setObjectMetaBuilderMutex.Lock()
	defer fake.setObjectMetaBuilderMutex.Unlock()
	fake.SetObjectMetaBuilderStub = nil
	if fake.setObjectMetaBuilderReturnsOnCall == nil {
		fake.setObjectMetaBuilderReturnsOnCall = make(map[int]struct {
			result1 k8s.IngressBuilder
		})
	}
	fake.setObjectMetaBuilderReturnsOnCall[i] = struct {
		result1 k8s.IngressBuilder
	}{result1}
}

func (fake *K8sIngressBuilder) SetPath(arg1 string) k8s.IngressBuilder {
	fake.setPathMutex.Lock()
	ret, specificReturn := fake.setPathReturnsOnCall[len(fake.setPathArgsForCall)]
	fake.setPathArgsForCall = append(fake.setPathArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.SetPathStub
	fakeReturns := fake.setPathReturns
	fake.recordInvocation("SetPath", []interface{}{arg1})
	fake.setPathMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *K8sIngressBuilder) SetPathCallCount() int {
	fake.setPathMutex.RLock()
	defer fake.setPathMutex.RUnlock()
	return len(fake.setPathArgsForCall)
}

func (fake *K8sIngressBuilder) SetPathCalls(stub func(string) k8s.IngressBuilder) {
	fake.setPathMutex.Lock()
	defer fake.setPathMutex.Unlock()
	fake.SetPathStub = stub
}

func (fake *K8sIngressBuilder) SetPathArgsForCall(i int) string {
	fake.setPathMutex.RLock()
	defer fake.setPathMutex.RUnlock()
	argsForCall := fake.setPathArgsForCall[i]
	return argsForCall.arg1
}

func (fake *K8sIngressBuilder) SetPathReturns(result1 k8s.IngressBuilder) {
	fake.setPathMutex.Lock()
	defer fake.setPathMutex.Unlock()
	fake.SetPathStub = nil
	fake.setPathReturns = struct {
		result1 k8s.IngressBuilder
	}{result1}
}

func (fake *K8sIngressBuilder) SetPathReturnsOnCall(i int, result1 k8s.IngressBuilder) {
	fake.setPathMutex.Lock()
	defer fake.setPathMutex.Unlock()
	fake.SetPathStub = nil
	if fake.setPathReturnsOnCall == nil {
		fake.setPathReturnsOnCall = make(map[int]struct {
			result1 k8s.IngressBuilder
		})
	}
	fake.setPathReturnsOnCall[i] = struct {
		result1 k8s.IngressBuilder
	}{result1}
}

func (fake *K8sIngressBuilder) SetServiceName(arg1 k8s.Name) k8s.IngressBuilder {
	fake.setServiceNameMutex.Lock()
	ret, specificReturn := fake.setServiceNameReturnsOnCall[len(fake.setServiceNameArgsForCall)]
	fake.setServiceNameArgsForCall = append(fake.setServiceNameArgsForCall, struct {
		arg1 k8s.Name
	}{arg1})
	stub := fake.SetServiceNameStub
	fakeReturns := fake.setServiceNameReturns
	fake.recordInvocation("SetServiceName", []interface{}{arg1})
	fake.setServiceNameMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *K8sIngressBuilder) SetServiceNameCallCount() int {
	fake.setServiceNameMutex.RLock()
	defer fake.setServiceNameMutex.RUnlock()
	return len(fake.setServiceNameArgsForCall)
}

func (fake *K8sIngressBuilder) SetServiceNameCalls(stub func(k8s.Name) k8s.IngressBuilder) {
	fake.setServiceNameMutex.Lock()
	defer fake.setServiceNameMutex.Unlock()
	fake.SetServiceNameStub = stub
}

func (fake *K8sIngressBuilder) SetServiceNameArgsForCall(i int) k8s.Name {
	fake.setServiceNameMutex.RLock()
	defer fake.setServiceNameMutex.RUnlock()
	argsForCall := fake.setServiceNameArgsForCall[i]
	return argsForCall.arg1
}

func (fake *K8sIngressBuilder) SetServiceNameReturns(result1 k8s.IngressBuilder) {
	fake.setServiceNameMutex.Lock()
	defer fake.setServiceNameMutex.Unlock()
	fake.SetServiceNameStub = nil
	fake.setServiceNameReturns = struct {
		result1 k8s.IngressBuilder
	}{result1}
}

func (fake *K8sIngressBuilder) SetServiceNameReturnsOnCall(i int, result1 k8s.IngressBuilder) {
	fake.setServiceNameMutex.Lock()
	defer fake.setServiceNameMutex.Unlock()
	fake.SetServiceNameStub = nil
	if fake.setServiceNameReturnsOnCall == nil {
		fake.setServiceNameReturnsOnCall = make(map[int]struct {
			result1 k8s.IngressBuilder
		})
	}
	fake.setServiceNameReturnsOnCall[i] = struct {
		result1 k8s.IngressBuilder
	}{result1}
}

func (fake *K8sIngressBuilder) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.buildMutex.RLock()
	defer fake.buildMutex.RUnlock()
	fake.setHostMutex.RLock()
	defer fake.setHostMutex.RUnlock()
	fake.setIngressClassNameMutex.RLock()
	defer fake.setIngressClassNameMutex.RUnlock()
	fake.setObjectMetaBuilderMutex.RLock()
	defer fake.setObjectMetaBuilderMutex.RUnlock()
	fake.setPathMutex.RLock()
	defer fake.setPathMutex.RUnlock()
	fake.setServiceNameMutex.RLock()
	defer fake.setServiceNameMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *K8sIngressBuilder) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ k8s.IngressBuilder = new(K8sIngressBuilder)
